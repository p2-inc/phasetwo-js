/* tslint:disable */
/* eslint-disable */
/**
 * Keycloak Account API
 * Derived from the code at https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java 
 *
 * The version of the OpenAPI document: 20.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountRepresentation,
  ClientRepresentation,
  ConsentRepresentation,
  CredentialRepresentation,
  DeviceRepresentation,
  GroupRepresentation,
  LinkedAccountRepresentation,
  SessionRepresentation,
} from '../models';
import {
    AccountRepresentationFromJSON,
    AccountRepresentationToJSON,
    ClientRepresentationFromJSON,
    ClientRepresentationToJSON,
    ConsentRepresentationFromJSON,
    ConsentRepresentationToJSON,
    CredentialRepresentationFromJSON,
    CredentialRepresentationToJSON,
    DeviceRepresentationFromJSON,
    DeviceRepresentationToJSON,
    GroupRepresentationFromJSON,
    GroupRepresentationToJSON,
    LinkedAccountRepresentationFromJSON,
    LinkedAccountRepresentationToJSON,
    SessionRepresentationFromJSON,
    SessionRepresentationToJSON,
} from '../models';

export interface CreateConsentRequest {
    realm: string;
    clientId: string;
}

export interface DeleteConsentRequest {
    realm: string;
    clientId: string;
}

export interface DeleteCredentialRequest {
    realm: string;
    credentialId: string;
}

export interface DeleteCurrentSessionRequest {
    realm: string;
}

export interface DeleteLinkedProviderRequest {
    realm: string;
    providerId: string;
}

export interface DeleteSessionRequest {
    realm: string;
    sessionId: string;
}

export interface GetAccountRequest {
    realm: string;
    userProfileMetadata?: boolean;
}

export interface GetApplicationsRequest {
    realm: string;
    name?: string;
}

export interface GetConsentRequest {
    realm: string;
    clientId: string;
}

export interface GetCredentialsRequest {
    realm: string;
    type?: string;
    userCredentials?: boolean;
}

export interface GetDevicesRequest {
    realm: string;
}

export interface GetGroupsRequest {
    realm: string;
    briefRepresentation?: boolean;
}

export interface GetLinkedAccountsRequest {
    realm: string;
}

export interface GetSessionsRequest {
    realm: string;
}

export interface UpdateAccountRequest {
    realm: string;
    accountRepresentation: AccountRepresentation;
}

export interface UpdateConsentRequest {
    realm: string;
    clientId: string;
}

export interface UpdateCredentialLabelRequest {
    realm: string;
    credentialId: string;
    body?: string;
}

/**
 * 
 */
export class AccountApi extends runtime.BaseAPI {

    /**
     * Create consent
     */
    async createConsentRaw(requestParameters: CreateConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConsentRepresentation>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling createConsent.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling createConsent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/applications/{clientId}/consent`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConsentRepresentationFromJSON(jsonValue));
    }

    /**
     * Create consent
     */
    async createConsent(requestParameters: CreateConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConsentRepresentation> {
        const response = await this.createConsentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete consent
     */
    async deleteConsentRaw(requestParameters: DeleteConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling deleteConsent.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling deleteConsent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/applications/{clientId}/consent`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete consent
     */
    async deleteConsent(requestParameters: DeleteConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteConsentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the credential
     */
    async deleteCredentialRaw(requestParameters: DeleteCredentialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling deleteCredential.');
        }

        if (requestParameters.credentialId === null || requestParameters.credentialId === undefined) {
            throw new runtime.RequiredError('credentialId','Required parameter requestParameters.credentialId was null or undefined when calling deleteCredential.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/credentials/{credentialId}`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"credentialId"}}`, encodeURIComponent(String(requestParameters.credentialId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the credential
     */
    async deleteCredential(requestParameters: DeleteCredentialRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCredentialRaw(requestParameters, initOverrides);
    }

    /**
     * Delete current session
     */
    async deleteCurrentSessionRaw(requestParameters: DeleteCurrentSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling deleteCurrentSession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/sessions`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete current session
     */
    async deleteCurrentSession(requestParameters: DeleteCurrentSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCurrentSessionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the linked provider
     */
    async deleteLinkedProviderRaw(requestParameters: DeleteLinkedProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling deleteLinkedProvider.');
        }

        if (requestParameters.providerId === null || requestParameters.providerId === undefined) {
            throw new runtime.RequiredError('providerId','Required parameter requestParameters.providerId was null or undefined when calling deleteLinkedProvider.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/linked-accounts/{providerId}`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"providerId"}}`, encodeURIComponent(String(requestParameters.providerId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the linked provider
     */
    async deleteLinkedProvider(requestParameters: DeleteLinkedProviderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteLinkedProviderRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the session
     */
    async deleteSessionRaw(requestParameters: DeleteSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling deleteSession.');
        }

        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling deleteSession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/sessions/{sessionId}`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"sessionId"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the session
     */
    async deleteSession(requestParameters: DeleteSessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSessionRaw(requestParameters, initOverrides);
    }

    /**
     * Get user details for currently logged in user
     * Get account
     */
    async getAccountRaw(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountRepresentation>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getAccount.');
        }

        const queryParameters: any = {};

        if (requestParameters.userProfileMetadata !== undefined) {
            queryParameters['userProfileMetadata'] = requestParameters.userProfileMetadata;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountRepresentationFromJSON(jsonValue));
    }

    /**
     * Get user details for currently logged in user
     * Get account
     */
    async getAccount(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountRepresentation> {
        const response = await this.getAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get applications
     */
    async getApplicationsRaw(requestParameters: GetApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ClientRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getApplications.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/applications`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ClientRepresentationFromJSON));
    }

    /**
     * Get applications
     */
    async getApplications(requestParameters: GetApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ClientRepresentation>> {
        const response = await this.getApplicationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get consent
     */
    async getConsentRaw(requestParameters: GetConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConsentRepresentation>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getConsent.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling getConsent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/applications/{clientId}/consent`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConsentRepresentationFromJSON(jsonValue));
    }

    /**
     * Get consent
     */
    async getConsent(requestParameters: GetConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConsentRepresentation> {
        const response = await this.getConsentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get credentials for currently logged in user
     * Get credentials
     */
    async getCredentialsRaw(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CredentialRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getCredentials.');
        }

        const queryParameters: any = {};

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.userCredentials !== undefined) {
            queryParameters['user-credentials'] = requestParameters.userCredentials;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/credentials`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CredentialRepresentationFromJSON));
    }

    /**
     * Get credentials for currently logged in user
     * Get credentials
     */
    async getCredentials(requestParameters: GetCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CredentialRepresentation>> {
        const response = await this.getCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get devices for currently logged in user
     * Get devices
     */
    async getDevicesRaw(requestParameters: GetDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DeviceRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getDevices.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/sessions/devices`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeviceRepresentationFromJSON));
    }

    /**
     * Get devices for currently logged in user
     * Get devices
     */
    async getDevices(requestParameters: GetDevicesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DeviceRepresentation>> {
        const response = await this.getDevicesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get groups that this user is a member of
     */
    async getGroupsRaw(requestParameters: GetGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GroupRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getGroups.');
        }

        const queryParameters: any = {};

        if (requestParameters.briefRepresentation !== undefined) {
            queryParameters['briefRepresentation'] = requestParameters.briefRepresentation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/groups`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupRepresentationFromJSON));
    }

    /**
     * Get groups that this user is a member of
     */
    async getGroups(requestParameters: GetGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GroupRepresentation>> {
        const response = await this.getGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get linked accounts for currently logged in user
     * Get linked accounts
     */
    async getLinkedAccountsRaw(requestParameters: GetLinkedAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LinkedAccountRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getLinkedAccounts.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/linked-accounts`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LinkedAccountRepresentationFromJSON));
    }

    /**
     * Get linked accounts for currently logged in user
     * Get linked accounts
     */
    async getLinkedAccounts(requestParameters: GetLinkedAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LinkedAccountRepresentation>> {
        const response = await this.getLinkedAccountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get sessions for currently logged in user
     * Get sessions
     */
    async getSessionsRaw(requestParameters: GetSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SessionRepresentation>>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling getSessions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/sessions`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SessionRepresentationFromJSON));
    }

    /**
     * Get sessions for currently logged in user
     * Get sessions
     */
    async getSessions(requestParameters: GetSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SessionRepresentation>> {
        const response = await this.getSessionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update account
     */
    async updateAccountRaw(requestParameters: UpdateAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling updateAccount.');
        }

        if (requestParameters.accountRepresentation === null || requestParameters.accountRepresentation === undefined) {
            throw new runtime.RequiredError('accountRepresentation','Required parameter requestParameters.accountRepresentation was null or undefined when calling updateAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountRepresentationToJSON(requestParameters.accountRepresentation),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update account
     */
    async updateAccount(requestParameters: UpdateAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateAccountRaw(requestParameters, initOverrides);
    }

    /**
     * Update consent
     */
    async updateConsentRaw(requestParameters: UpdateConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConsentRepresentation>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling updateConsent.');
        }

        if (requestParameters.clientId === null || requestParameters.clientId === undefined) {
            throw new runtime.RequiredError('clientId','Required parameter requestParameters.clientId was null or undefined when calling updateConsent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/applications/{clientId}/consent`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"clientId"}}`, encodeURIComponent(String(requestParameters.clientId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConsentRepresentationFromJSON(jsonValue));
    }

    /**
     * Update consent
     */
    async updateConsent(requestParameters: UpdateConsentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConsentRepresentation> {
        const response = await this.updateConsentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a user label of specified credential of current user
     */
    async updateCredentialLabelRaw(requestParameters: UpdateCredentialLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.realm === null || requestParameters.realm === undefined) {
            throw new runtime.RequiredError('realm','Required parameter requestParameters.realm was null or undefined when calling updateCredentialLabel.');
        }

        if (requestParameters.credentialId === null || requestParameters.credentialId === undefined) {
            throw new runtime.RequiredError('credentialId','Required parameter requestParameters.credentialId was null or undefined when calling updateCredentialLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access_token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/{realm}/account/credentials/{credentialId}/label`.replace(`{${"realm"}}`, encodeURIComponent(String(requestParameters.realm))).replace(`{${"credentialId"}}`, encodeURIComponent(String(requestParameters.credentialId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update a user label of specified credential of current user
     */
    async updateCredentialLabel(requestParameters: UpdateCredentialLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateCredentialLabelRaw(requestParameters, initOverrides);
    }

}
